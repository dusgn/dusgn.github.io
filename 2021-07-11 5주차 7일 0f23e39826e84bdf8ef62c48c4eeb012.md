# 2021-07-11 5주차 7일

강의를 다시 들어볼까 말까 하는 고민이 많았다.

코드로 짜보는게 중요하겠지만 모른다는 불안감 때문에 과제구현에 집중이 잘 안된다.

그리고 9일에 강의를 들어보니 처음듣는 내용이 아니라 그런지 머릿속에 남는 기분이 들었다.

우선 다시 들어보고 월요일 저녁부턴 프로젝트 하는걸로 방향을 잡아보자

웹개발의 봄,Spring 기본편(강의를 재수강하진 않고 강의자료 복기)

#1  Rest

서버의 응답이 JSON 형식임

REST란, 주소에 명사, 요청 방식에 동사를 사용함으로써 의도를 명확히 드러냄을 의미

동사는 우리가 JPA 시간에 배운 CRUD를 지칭

생성(POST)/조회(GET)/수정(PUT)/삭제(DELETE) 요청

HTML, CSS 등을 주고 받을 때는 Rest.를 붙이지 않음

#2 Controller

자동응답기(클라이언트의 요청을 전달받음)

JSON만을 돌려주는 것을 RESTController

#3 @GetMapping

브라우저에서 주소를 치는 행위 GET

#4 인메모리디비

서버가 작동하는 동안에만 내용을 저장하고, 동작을 멈추면 데이터가 모두 삭제되는 데이터베이스

#5 domain, repository

스프링 - rdbms

domain - table

repository - sql

#6 interface란

JPA는 Repository를 통해서만 사용할 수 있습니다.

인터페이스는 클래스에서 멤버가 빠진, 메소드 모음집

이 상속으로 repository.() 에 함수들을 갖다 쓸수 있게됨

#7 Timestamped

DB 기본 중의 기본은, 생성일자와 수정일자를 필드로 가지는 것

```java
@MappedSuperclass // 상속했을 때 Entity가 자동으로 컬럼으로 인식합니다.
@EntityListeners(AuditingEntityListener.class) // 생성/변경 시간을 자동으로 업데이트합니다.
public abstract class Timestamped {// abstract 상속으로만 쓸수있는 클래스이다.

    @CreatedDate    // 생성일자임을 나타냅니다.
    private LocalDateTime createdAt;

    @LastModifiedDate   // 마지막 수정일자임을 나타냅니다.
    private LocalDateTime modifiedAt;
}

/*
* Application클래스에 @EnableJpaAuditing 추가해 줘야 함
* 디비에만 갖다 쓰는게 아니라 조회하려면(가져다 쓰려면) @Getter 해줘야 함
*/
```

#8 JPA Auditing

Java에서 ORM 기술인 JPA를 사용하여 도메인을 관계형 데이터베이스 테이블에 매핑할 때 공통적으로 도메인들이 가지고 있는 필드나 컬럼들이 존재한다. 대표적으로 생성일자, 수정일자, 식별자 같은 필드 및 컬럼등이 있다. 누가 언제 기록했는지 로그를 잘 남겨야 하기 때문에 생성일, 수정일은 중요하다. 그래서 JPA에서 Audit 이라는 기능을 제공한다. Audit 감시하다, 감독하다 란 뜻으로 스프링 데이터JPA에서 해당 데이터를 지켜보고 있다가 생성 또는 수정이 발생한시간에 대해서 자동으로 값을 넣어주는 기능이다. 

#9  @RequiredArgsConstructor

```java
@Service
public class CourseService {

    // final: 서비스에게 꼭 필요한 녀석임을 명시 , 업데이트하고 이럴때 써야되니까
    private final CourseRepository courseRepository;

    public CourseService(CourseRepository courseRepository){
        this.courseRepository = courseRepository;
    }
```

롬복(lombok) 적용 후 부터 아래처럼 써주면 됨 다 넣어줌

```java
@RequiredArgsConstructor //생성자를 자동으로 생성해줌
@Service
public class CourseService {

    // final: 서비스에게 꼭 필요한 녀석임을 명시 , 업데이트하고 이럴때 써야되니까
    private final CourseRepository courseRepository;
```

#10 DTO

@Getter, Setter, 필드 final 로 하고RequiredArgsConstructor 그냥 적지말고 한 개씩 넣어보면서 왜 되는지 생각좀학기

#11 API 명명규칙

- 주소에 들어가는 명사들은 복수형을 사용합니다.
    - /course
- 주소에 동사는 가급적 사용하지 않습니다.
    - /accounts/edit

#12 dto 관련

```java
@RequiredArgsConstructor
@RestController
public class CourseController {

    private final CourseRepository courseRepository;

    private final CourseService courseService;

    // PostMapping을 통해서, 같은 주소라도 방식이 다름을 구분합니다.
    @PostMapping("/api/courses")
    public Course createCourse(@RequestBody CourseRequestDTO requestDto) {
				// 스프링은 주고 받는 방식을 강제한다.
				// @RequestBody가 없으면 받는 정보가 잘 안들어옴
				// requestDto 안에 받겠다. 스프링이 넣어줌

        // requestDto 는, 생성 요청을 의미합니다.
        // 강의 정보를 만들기 위해서는 강의 제목과 튜터 이름이 필요하잖아요?
        // 그 정보를 가져오는 녀석입니다.

        // 저장하는 것은 Dto가 아니라 Course이니, Dto의 정보를 course에 담아야 합니다.
        // 잠시 뒤 새로운 생성자를 만듭니다.
				//여기선 컨트롤러 단에서 담음
        Course course = new Course(requestDto);

        // JPA를 이용하여 DB에 저장하고, 그 결과를 반환합니다.
        return courseRepository.save(course);
    }
```

#13 JSON.stringify

API 들간 정보를 주고 받을땐 문자열만 주고 받음

숫자,. 문자, 제이슨도 많으니까 받는 쪽에 우리가 제약이 있어서 문자열로 보내는데 이거 사실 제이슨임(content-type에 json을 넣어주는거)

```jsx
$.ajax({
    type: "POST",
    url: "/api/memos",
    contentType: "application/json", // JSON 형식으로 전달함을 알리기
    data: JSON.stringify(data),
    success: function (response) {
        alert('메시지가 성공적으로 작성되었습니다.');
        window.location.reload();
    }
});
```

#14 생성 조회 변경 삭제를 어디에서 구현할지도 생각해보자

MemoController.java

```java
@RequiredArgsConstructor
@RestController // controller도 사용을 위해 new Controller 해야되는데 이걸 해줌
public class MemoController {
    /*
     * 우리가 필요한 기능은? 생성 조회 변경 삭제
     * 변경 > update(service)
     * 생성 조회 삭제 > Repository
     * */
    private final MemoRepository memoRepository;
    private final MemoService memoService;

    @PostMapping("/api/memos")
    public Memo createMemo(@RequestBody MemoRequestDto requestDto) {
        Memo memo = new Memo(requestDto);
        return memoRepository.save(memo);   // save는 알아서 리턴함
    }

    @GetMapping("/api/memos")
    public List<Memo> readMemo() {
        LocalDateTime start = LocalDateTime.now().minusDays(1);
        LocalDateTime end = LocalDateTime.now();
        return memoRepository.findAllByModifiedAtBetweenOrderByModifiedAtDesc(start, end);
    }

    @DeleteMapping("/api/memos/{id}")
    public Long deleteMemo(@PathVariable Long id) {
        memoRepository.deleteById(id);
        return id;
    }

    @PutMapping("/api/memos/{id}")
    public Long updateMemo(@PathVariable Long id, @RequestBody MemoRequestDto requestDto) {
        return memoService.update(id, requestDto);
    }

}
```

 MemoService.java

```java
@RequiredArgsConstructor
@Service
public class MemoService {
    /*
     * final을 지정해줘야한다. Service를 이용할 때 스프링이 적절히 Repository를 넣어주지 못할수도 있어서 꼭필요하다고 얘기해주고
     * @RequiredArgsConstructor > final이 있으면 생성할때 우리애좀 챙겨줘... 라고 알려주는 장치
     * */
    private final MemoRepository memoRepository;

    /*
     * 우리는 메모 변경 즉 update 메서드가 필요함
     * 그럼 우선 적어줌 public 반환타입 메서드명
     * 인자를 받아야 할게 있나 생각해봄... 있음 어떤 데이터를 어떻게 수정할지 받아야함 그럼 파라메타로 (어떤 데이터, 바꿔줄 데이터)를 지정함
     * 메서드 바디를 적어보자
     * 우선 어떤 데이터로 찾아야 하기 때문에 repository가 필요하니 선언해줌  private final Repository repository
     * 근데 없을 경우도 있으니 오류 처리를 해줌
     * NullpointerException > 가르키는게 없다 즉 내가 찾는 대상이 없다.
     * IllegalArgumentException > 파라미터가 잘못되어있다.
     * 결과를 담아서 데이터를 업데이트 해주고 반환데이터를 지정하고 반환타입도 지정해줌
     * 그리고 이게 데베에 꼭꼭 반영이 되어야해 라고 Transactional 을 넣어주어야 함*/
    @Transactional
    public Long update(Long id, MemoRequestDto requestDto) {
        Memo memo = memoRepository.findById(id).orElseThrow(
                () -> new IllegalArgumentException("아이디가 존재하지 않습니다.")
        );
        memo.update(requestDto);
        return memo.getId();
    }
}
```

#15 4주차 이번주 배울것

 3계층(Controller, Service, Repository) 숙달과 API handling은 무엇보다 중요한 기본기라고 할 수 있는데요.

1. 3계층 숙달
    - 스프링, 아니 개발의 핵심 중 하나가 분업과 느슨한 결합입니다. 각자가 맡은 바 책임을 다하면 기능이 온전히 작동하고, 느슨히 결합함으로써 유연성과 확장성을 가지기 때문이지요.
    - 3계층은 분업과 느슨한 결합의 대표적인 예시이자, 스프링이 돌아가게 만드는 척추입니다.
    - 깊게 파자면 끝없는 이론이 있지만, 지금은 그것보다 우선 손에 익게 하는데 집중하세요. 손에 익어서, "아 나도 웬만한 사이트는 노력하면 만들 수 있지!"라는 자신감을 가지는게 정말 중요해요.
2. API handling
    - 혼자 하는 개발은 없습니다. 그리고 세상에는 다양한 API가 있습니다. API를 잘 다루면 재미있는 나만의 서비스를 더 많이, 더 빠르게 만들 수 있고 그럼으로써 개발자로 한 단계 성장할 수 있습니다.
    - 또한, 앞에서 말씀드린 느슨한 결합의 대표적인 예시가 바로 API 입니다. 우리가 이용할 네이버 검색 API의 내부 로직이 어떻게 되든 상관없이, 우리는 정해진 약속대로 요구하면 정해진 결과를 받을 수 있지요.
    - 한 마디로 API가 아무리 많아도 쓸 줄 모르면 무용지물이죠. 그런데 JSON으로 주고받는 데이터를 어떻게 자바로 요청하고, 그 결과를 다룰 수 있는지 모르는 분들이 생각보다 많습니다. 이번에 그 기초를 확실하게 배워볼게요!

    #16 3계층 설계 예시

    1. Controller
        - ProductRestController: 관심 상품 관련 컨트롤러

            전체 상품 목록 조회의 경우 바로 Repository에서 꺼내옴

            post requestdto로 받아서 바로 repository로 save()

        - SearchRequestController: 검색 관련 컨트롤러
    2. Service
        - ProductService: 관심 상품 가격 변경

            dto로 넘겨받은걸 아이디 찾아서 레포에 findById 한것을 product에 넣고 product.update(requestDto)

    3. Repository

        여기서 DB에 저장되는 녀석은 Product 뿐이라는 점!

        - Product: 관심 상품 테이블
        - ProductRepository: 관심 상품 조회, 저장
        - ProductRequestDto: 관심 상품 등록하기
        - ProductMypriceRequestDto: 관심 가격 변경하기
        - ItemDto: 검색 결과 주고받기

        #17 검색 결과를 문자열에서 DTO로 바꾸기

        - org.json 패키지 설치

            JSON을 자바에서 다루기 위해, JSONObject, JSONArray 클래스가 필요합니다.
            우리가  만드는 대신, 다른 사람이 만든 훌륭한 라이브러리를 바로 가져와서 사용하겠습니다.
            JSONObject( { " " , " " }  한개, JSONArray JSONObject의 배열
            이번 시간에는 "다른 사람이 만든 라이브러리 가져오는 방법(임포트)"에 대해 배워보겠습니다.

            1. 구글에 maven central 검색 후 첫 번째 결과 클릭
            2. 검색창에 json 입력 후 엔터
            3. JSON In Java 클릭
            4. 숫자 가장 높은 버전 클릭
            5. Gradle 탭 클릭
            6. 내용 복사하여 build.gradle > dependencies 안에 붙여넣기
            7. dependencies 옆의 Run 버튼 클릭
            8. 임포트 완료!
            - JSONObject, JSONArray
                1. **[코드스니펫] 문자열 정보를 JSONObject로 바꾸기**

                    ```java
                    String result = ...
                    JSONObject rjson = new JSONObject(result);
                    ```

                2. **[코드스니펫] JSONObject에서 items 배열 꺼내기**

                    ```java
                    JSONArray items = rjson.getJSONArray("items");
                    //items는 키값
                    ```

                3. **[코드스니펫] JSONArray 로 for 문 돌기**

                    ```java
                    for (int i=0; i<items.length(); i++) {
                    	JSONObject itemJson = (JSONObject) items.get(i);
                    	System.out.println(itemJson);
                    }
                    ```

                4. **[코드스니펫] JSONObject 에서 String, int 데이터 뽑기**

                    ```java
                    String title = itemJson.getString("title");
                    int lprice = itemJson.getInt("lprice");
                    // 꺼낼자료형 이름 = JSonObject.get자료형(키값)
                    ```

        #18 Component 등록

        컴포넌트로 등록을 하면 개발자가 스프링에게 권한을 줌

        필요할 때 알아서 가져다 쓰라고 정해줌

        final일 때  @RequiredArgsConstructor 를 해주잖아... 이게 알아서 넣어주긴 하는데 component 등록이 안되어있으면 불가능함 그래서 Service나 Repository 도 componentscan방식이라 저거 써주면 스프링이 넣어주는거

        #19 api mapping

        GET /api/search**?query**=검색어

        mapping을 물음표 전까지 해줌 주소는 물음표 앞까지고 더불어 온다는뜻

        @GetMapping("/api/search")
            public List<ItemDto> getItems(@RequestParam String **query**

        @RequestParam 요청할 때 따라오는 애를 query에 넣어줘라 **변수명이 같아야함**...

        그래야 스프링이 어디넣어줄질 암

        #20 

        ```java
        @RequiredArgsConstructor // final 멤버 변수를 자동으로 생성합니다.
        @Component // 스프링이 필요 시 자동으로 생성하는 클래스 목록에 추가합니다.
        public class Scheduler {

            private final ProductRepository productRepository;
            private final ProductService productService;
            private final NaverShopSearch naverShopSearch;

            // 초, 분, 시, 일, 월, 주 순서 이 시간이 되었을때 해당 함수를 실행 cron이 해줌
            @Scheduled(cron = "0 0 1 * * *")
            public void updatePrice() throws InterruptedException {   // 오류가 발생하면 이렇게
                System.out.println("가격 업데이트 실행");
                // 저장된 모든 관심상품을 조회합니다.
                List<Product> productList = productRepository.findAll(); 
                for (int i=0; i<productList.size(); i++) {
                    // 1초에 한 상품 씩 조회합니다 (코드는 문제없는데 Naver 제한) 
                    TimeUnit.SECONDS.sleep(1);
                    // i 번째 관심 상품을 꺼냅니다.
                    Product p = productList.get(i);
                    // i 번째 관심 상품의 제목으로 검색을 실행합니다.
                    String title = p.getTitle();
                    String resultString = naverShopSearch.search(title);
                    // i 번째 관심 상품의 검색 결과 목록 중에서 첫 번째 결과를 꺼냅니다.
                    List<ItemDto> itemDtoList = naverShopSearch.fromJSONtoItems(resultString);
                    ItemDto itemDto = itemDtoList.get(0);
                    // i 번째 관심 상품 정보를 업데이트합니다.
                    Long id = p.getId();
                    productService.updateBySearch(id, itemDto);
                }
            }
        }

        // 스캐쥴러가 있으면 있다고 application에 @EnableScheduling 해줘야 부트에서 스케줄러 작동함
        ```

    웹개발의 봄,Spring 기본편(강의를 재수강하진 않고 강의자료 복기)

    #1 서블릿(Servlet)

    자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양

    스프링 없이 자바를 사용한 서버구현이 가능

    그럼 스프링은 왜 쓸까

    클라이언트(javascript)와 서버(Java)가 사용하는 언어가 다름

    그래서 중간에 JSON형태로 연락함

    javascript ↔ JSON ↔ Java

    그래서 서버에서 Json으로 들어온 요청을 자바 객체로 바꾸고 보내줄 땐 자바 객체를 JSON 으로 변환하는 과정을 거쳐 응답을 보내야함

    URL정보도 빼내 컨트롤러로 보내주는 구문을 작성해야함

    이걸 스프링이 해주게됨 

    #2 스프링IoC 컨테이너

    빈 : 스프링이 생성해주는 객체

    스프링  IoC 컨테이너 : 빈을 모아둔 통

    **[ @Bean, @Configuration ]**

    - 개발자가 직접 제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 Bean으로 등록할 때 @Bean 어노테이션을 활용
    - 1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration을 명시해 주어야 함

    **[ @Component ]**

    - 개발자가 직접 개발한 클래스를 Bean으로 등록하고자 하는 경우 @Component 어노테이션을 활용
    - Q. 왜 update만 Service 에서 관리하나요?
        - Repository 에 update 메소드가 없기 때문입니다.
        - @Transactional 이라는 어노테이션을 통해, 찾은 객체의 데이터를 변경할 경우 DB에 반영되도록 설정한 것입니다.